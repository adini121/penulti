\chapter{Background}
\label{Chapter2}
% Main chapter title
\lhead{Chapter 2. \emph{Background}}


This chapter introduces the background necessary to understand the concepts and methods presented in this thesis. Important terminologies essential for the foundation of this thesis are explained in subsequent sections throughout this chapter.

As majority of web applications' functionality is accessed through the GUI layer, it becomes customary to test important functional use-cases on the AUT through the GUI layer. For this purpose, there exists different set of mechanisms. Section \ref{sec:AutomatedGUITesting} gives a brief insight into these automated GUI testing mechanisms.

In recent years, Selenium\cite{websiteSelenium} has been a popular browser test automation tool of choice among software developers and testers. Section \ref{sec:SeleniumTesting} gives the necessary background about Selenium framework, including its implementation techniques as well as salient features.

This research leverages existing Selenium tests to capture the behavior of the AUT in terms of finite state models. For this purpose, the tool \texttt{webmate}, presented by Dallmeier et al.\cite{webmate} has been used. By leveraging existing Selenium tests, \texttt{webmate} can systematically explore the AUT to extract its behavioral usage model by implementing state-abstraction for comparing similar GUI states of the AUT. Further details about \texttt{webmate} are discussed in Section \ref{sec:WebMate}

Section \ref{sec:Statistical} presents the statistical background required to analyze the results and apply the evaluation metrics, as presented in Chapter \ref{Chapter6}.

\section{Automated GUI Testing}
\label{sec:AutomatedGUITesting}
As mentioned in Section 1, testing web applications at GUI level abstracts away finer grained internal details and helps developers to identify the undesired functionality changes in the AUT.  In comparison to traditional command-line applications or Application Programming Interfaces (APIs), automated GUI testing of modern web 2.0 applications built with multiple languages, platforms and server-side technologies poses new challenges.

To begin with, automatically generating and selecting inputs for a GUI is difficult since depending upon the type of the application, different applications might require specific combinations of inputs and values. 
Current practices for automated test input generation include techniques such as symbolic execution\cite{Ganovetal}, using random input generation\cite{godefroid2005dart} or search based techniques\cite{gross2012search}.

However, automated input generation is not trivial for a web applications, since the GUI test automation tool needs to be aware of the context of the AUT. Although test inputs can be generated using functional specifications, concrete specifications along with different input combinations may not be available in practice and desired functional coverage of the AUT is not achieved. Thus in many cases, input generation is often left to the test developer to explore the desired states of the AUT hidden behind input forms and elements.

In addition, even in cases when a testing tool can generate different input combinations automatically, it still needs to verify the correct behavior of the AUT. This is usually done by applying appropriate test assertions and oracles on the test outputs\cite{Baresi:Oracles}. Mechanisms such as using Capture/replay tools\cite{joshi2006capture} require the tester to first manually capture the behavior of the AUT by performing different GUI-level events, recording them and storing the expected output as a part of the test-case. In the replay phase, recorded tests are replayed on the AUT and the output is checked against the captured textit{expected output} to assert the application behavior. Such approach requires manual effort to record each test and is not suitable for regression testing as every time the AUT changes\cite{sjosten2006costs}, there is a need to re-record the tests in order to generate new expected outputs. 

Moreover, as the size of the AUT increases, the number of possible actions on the GUI increases exponentially. This is especially an issue in case of regression testing since as possible number of paths and sequences increases, covering the entire possible number of state space and executions becomes infeasible.

In comparison to automated testing tools such as crawlers and test generators, humans possess the domain knowledge of the AUT required to generate valid test inputs and apply precise oracles on the test outputs. Thus, many developers often choose to identify the core functionality of the AUT and automate their regression tests using frameworks such as Selenium\cite{websiteSelenium}, as detailed in Section 2.2.

\section{Test automation using Selenium}
\label{sec:SeleniumTesting}
\subsection{Architecture}
\label{ssec:webdriverArchitecture}
Selenium is a browser automation framework designed to automate the system testing of web applications. While the Selenium project offers a different set of tools depending upon the type of application, the  \texttt{webdriver}\footnote{\url{http://www.seleniumhq.org/projects/webdriver/}} project is of particular the interest for laying the foundation of this thesis. The \texttt{webdriver} project provides an API to test dynamic web 2.0 applications. 

The \texttt{webdriver} API supports various modern programming languages such as Java, Python, C\#, Ruby, PHP etc. by providing language level bindings along with a set of browser specific drivers. Figure \ref{fig:webdriverArchitecture} gives an overview of the architecture of Selenium \texttt{webdriver}.

The API \textit{drives} (controls) the browser in a manner that it emulates all possible end users interactions with the browser, such as clicks, form-inputs, drag-drops, file uploads etc. Selenium \texttt{webdriver} tests can thus explore the possible set of functionalities of the AUT. As an example, Snippet \ref{code1} illustrates a \texttt{webdriver} test case (Java) to test the \textit{login} functionality of AUT as depicted in Figure \ref{fig:a}.
\begin{center}
\begin{scriptsize}
\centering
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
%   frame=none,
}
% \verb|basicstyle=\ttfamily, columns=fullflexible, keepspaces=true|
  
\begin{lstlisting}[caption=Login test,label=code1]
public void loginTest(){
driver.get("http://www.application-under-test.com");
driver.findElement(By.id("uname")).sendKeys("user");
driver.findElement(By.id("pwd")).sendKeys("passwd");
driver.findElement(By.linkText("Login")).click();
}
\end{lstlisting}
\end{scriptsize} 
\end{center}
 
\begin{figure}[h!]
\makeatletter 
% \renewcommand{\thefigure}{\@arabic\c@figure}
\makeatother
    \centering
  \includegraphics[width=5.5in,height=2.2in]{./Figures/webdriver_Archi}
  \caption{Selenium \texttt{webdriver} architecture}
  \label{fig:webdriverArchitecture} 
\end{figure}

The \texttt{webdriver} API communicates with the browser specific driver using a common wire protocol. The protocol transfers the test-commands written in language specific bindings to the browser specific driver in the form of UTF-8\footnote{\url{https://tools.ietf.org/html/rfc3629}} encoded JSON\footnote{\url{http://www.json.org/}} data. The API uses HTTP\footnote{\url{https://www.w3.org/Protocols/}} as a transport mechanism to transfer these commands to the driver and to return the response from the driver to the language specific code. 
\noindent 
Following example illustrates the communication between the language specific test-commands (Java in this case) and the \texttt{RemoteWebDriver} through \texttt{webdriver} API :
\begin{enumerate}
\item The client (test-script) requests the URL of the AUT.\\
\begin{small}
\texttt{driver.get("http://www.application-under-test.com");}
\end{small}
\item This command is translated as a JSON object to be transferred using the wire protocol as following:\\
\begin{small}
\texttt{\{"url": "http://www.application-under-test.com"\}}
\end{small}
\item The JSON object is then sent over HTTP (using POST\footnote{\url{http://tools.ietf.org/html/rfc7231\#section-4.3.3}} request in this case). To identify and associate each request/response session uniquely to the session-specific commands, \texttt{webdriver} uses a unique handle in terms of the \textit{SessionId}\footnote{\url{https://w3c.github.io/webdriver/webdriver-spec.html\#sessions}}\\
\begin{small}
\texttt{Method : POST, Path: session/{session-id}/url}\\
\end{small}
The resultant URL is :\\
\begin{small}
\texttt{http://localhost:7055/hub/session/{session-id}/url}
\end{small}
\end{enumerate}

Each browser specific driver implementation such as the \texttt{Firefox Driver}\footnote{\url{https://code.google.com/p/selenium/wiki/FirefoxDriver}} or the \texttt{RemoteWebDriver}\footnote{\url{https://code.google.com/p/selenium/wiki/RemoteWebDriver}} has its own mechanism for carrying out the above-mentioned communication. 

The \texttt{RemoteWebDriver} implementation provides the capability to run the Selenium tests against a remote machine. In essence, \texttt{RemoteWebDriver} is comprised of a client-server architecture, where client is the language specific test-case and and server is a simple Java servlet. The \texttt{RemoteWebDriver} servlet acts as a multiplexer, by connecting the client to the specific browser(s) and system configurations requested by the client. The browser and other configurations are provided in terms of capabilities, via command-line or directly from the language specific code.

\subsection{Locating UI Elements}
\label{ssec:locatingUIElements}
In order to locate GUI elements such as input forms, buttons, checkboxes etc. in the DOM (Document Object Model), \texttt{webdriver} specifies \textit{``Find Element''} and \textit{``Find Elements''} methods for locating a single element and a list of elements, respectively. Within the scope of these methods it is also possible to traverse the DOM tree to locate the \textit{Child Elements} i.e. children nodes of a parent element in the tree. Each language specific binding has its own command to invoke these methods by providing the UI-element locator object, such as\begin{small} HTML\end{small} \texttt{id}, the \texttt{css selector} or \texttt{xpath} expressions.

\begin{verbatim}
\#Classification : STRUCTURAL VS NON-STRUCTURAL
\#ADVANTAGE/PROPERTIES IN SHORT
\#IMPLEMENTATION EXAMPLE,
\end{verbatim}

The most commonly  used\footnote{\url{http://www.seleniumhq.org/docs/03_webdriver.jsp\#locating-ui-elements-webelements}} UI locators and their implementation in Java is listed as following:
\begin{itemize}
% ### ID
\item 
By \texttt{id}:
Locates the UI Element using \texttt{id} attribute of \begin{footnotesize} HTML\end{footnotesize} element.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<input id="login" type="button"/>}}
\texttt{WebElement loginButton = driver.findElement(By.id("login"));
}
\end{footnotesize}
% Locating UI Elements using unique HTML \texttt{id} attributes is the most preferred and reliable method\footnote{\url{http://www.seleniumhq.org/docs/03_webdriver.jsp\#by-id}}.  
% #NAME
\item 
By \texttt{name}:
Locates the UI Element using \texttt{name} attribute of \begin{footnotesize} HTML\end{footnotesize} element.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<input type="button" name="login"/>
}}
\texttt{WebElement loginButton = driver.findElement(By.name("login"));
}
\end{footnotesize}
% #Class name
\item 
By \texttt{class name}:
Locates the UI Element using the value of \begin{footnotesize} HTML\end{footnotesize} \texttt{class} attribute.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<input type="button" class="login"/>
}}
\texttt{WebElement loginButton = driver.findElement(By.className("login"));
}
\end{footnotesize}

% #tag name
\item 
By \texttt{tag name}:
Locates the UI Element using the \begin{footnotesize} HTML\end{footnotesize} \texttt{tag} attribute.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<button name="login"</button>
}}
\texttt{WebElement loginButton = driver.findElement(By.tagName("button"));
}
\end{footnotesize}

% #link text
\item 
By \texttt{link text}:
Locates the UI Element using the visible text of the hyperlink.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<a href="\#">Login</a>}}
\texttt{WebElement loginButton = driver.findElement(By.linkText("Login"));
}
\end{footnotesize}

% # partial link text
\item 
By \texttt{partial link text}:
Locates the UI Element by partial matching of visible text of the hyperlink.
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<a href="\#">Login Here</a>}}
\texttt{WebElement loginButton = driver.findElement(By.partialLinkText("Login"));
}
\end{footnotesize}
% # CSS
\item 
By \texttt{css selector}:
Locates the UI Element using the \texttt{css selector} representing the \begin{footnotesize} HTML\end{footnotesize} \texttt{tags, name, class and id} attributes through various combinations.\texttt{css selectors} also allow locating parent and children nodes of a DOM tree. 
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<input id="login"/>
}}
\texttt{WebElement loginButton = driver.findElement(By.cssSelector("input\#login"));
}
\end{footnotesize}
% # xpath
\item 
By \texttt{xpath}:
Locates the UI Element using the \texttt{xpath} expressions as it supports navigating XML as well as xHTML element tree.Similar to \texttt{css selectors}, the \texttt{xpath} expressions also allow locating parent and children nodes of a DOM tree. 
\newline
\begin{footnotesize}
\framecolorbox[\linewidth][l]{gray}{white}{\texttt{<input id="login"/>
}}
\texttt{WebElement loginButton = driver.findElement(By.xpath("//input[@id="login"]"));
}
\end{footnotesize}
\end{itemize}
Depending upon the GUI structure of AUT and the applicability of UI element locators, different location strategies can be used in combination. The Influence of these UI locator strategies on the robustness of Selenium tests is discussed in Chapter \ref{Chapter4}.
% (https://w3c.github.io/webdriver/webdriver-spec.html#sessions)

\section{WebMate}
\label{sec:WebMate}
As mentioned in Chapter \ref{Chapter1}, \texttt{webmate}\cite{webmate} is a system-level automated testing and analysis framework. Primarily developed as a cross-browser compatibility testing tool,\texttt{webmate} supports different browsers and platforms. It can leverage existing Selenium tests in order to remote control the browser to interact with the dynamic web 2.0 applications involving JavaScript and Ajax elements. 

By leveraging the Selenium tests, \texttt{webmate} explores the AUT and extracts a behavioral usage-model. The usage-model is essentially a finite state automaton which captures the exploration graph of the different actions performed by the Selenium test on the AUT. 

Figure \ref{fig:webmateArchitecture} gives an example of \texttt{webmate} leveraging the \texttt{loginTest} (Snippet \ref{code1}) to generate the usage-model. For security reasons, Selenium tests are integrated with \texttt{webmate} inside a virtual machine. The virtual machine hosts a Selenium hub\footnote{\url{http://www.seleniumhq.org/docs/07_selenium_grid.jsp}} infrastructure, along with a set of browsers. Existing Selenium tests can be executed with \texttt{webmate} by using the \texttt{RemoteWebDriver} capabilities, such as by specifying browser name, security credentials for \texttt{webmate} etc. \texttt{webmate} generates the usage-model without affecting the underlying Selenium tests.

The states of the usage-model correspond to different states of the GUI and the transitions correspond to different interactions with the AUT such as clicks, form-inputs etc. For each state of the usage-model, \texttt{webmate} is able to record its visual (GUI) state, in the form of a screen-shot of the AUT. \texttt{webmate} makes it possible to recognize functional differences (e.g. missing button) by assessing the usage models to compare GUI state and trace level differences. Due to these features of \texttt{webmate}, it is used as a tool of choice in this thesis for establishing the ground truth for the robustness analysis, as detailed in Chapter \ref{Chapter6}

\begin{figure}
\makeatletter 
% \renewcommand{\thefigure}{\@arabic\c@figure}
\makeatother
    \centering
  \includegraphics[width=5.5in,height=3in]{./Figures/webmate-state-graph}
  \caption{Webmate architecture}
  \label{fig:webmateArchitecture} 
\end{figure}

\section{Web Application Deployment}
\label{sec:autoDeployment}
To measure and evaluate the robustness of Selenium tests across different versions of AUT, it is customary to make these versions accessible for the testing setup as shown in Figure \ref{fig:thesisoverview}. It is possible to accomplish this by installing and deploying these versions locally (without relying on external application server provider). Generally, most of the open-source application vendors make older versions of their applications available for public usage. The most common ways to release such web applications are either by releasing packaged versions ready to deploy, such as \texttt{war} (Web application ARchive) files in case of Java applications or by checking out the code from version control repositories such as git, subversion, mercurial etc.

\begin{figure}
\makeatletter 
\renewcommand{\thefigure}{\@arabic\c@figure}
\makeatother
% \setcounter{figure}{0}
    \centering
  \includegraphics[width=5.4in,height=2.6in]{./Figures/Deployment_Process_2.jpg}
  \caption{Automatic parallel deployment process}
  \label{fig:deployment} 
\end{figure}

Depending upon the type of the web application as well as the frameworks and programming languages used to create these application, different set of application servers need to be used. Java based packaged applications such as \texttt{war} archives can be deployed in Java containers such as Tomcat\footnote{\url{http://tomcat.apache.org/}}. Similarly, PHP based applications can be hosted inside Apache httpd\footnote{\url{https://httpd.apache.org/}} servers. 

The AUT can be deployed as per the installation instructions provided by the application vendors. Such installation setup includes steps such as downloading the application source code or packaged binaries, creating databases and other configurations etc. Certain Selenium tests require the AUT to have some pre-configured features enabled, such as an \textit{administrative} user account setup which can also be accomplished in the installation phase. 

In order to spare the manual effort of installing multiple versions of AUT, the deployment work-flow can be automated through means of deployment scripts such as automated shell scripts. To further expedite the testing process, we aim to deploy multiple versions of the AUT in parallel, sand-boxed inside a secure Linux based virtual machine for security reasons. Figure \ref{fig:deployment} depicts the overview of remote automatic deployment process; three versions of the AUT are running simultaneously against their individual database instances.

% \begin{figure}
% \makeatletter 
% \renewcommand{\thefigure}{\@arabic\c@figure}
% \makeatother
% % \setcounter{figure}{0}
%     \centering
%   \includegraphics[width=5.4in,height=2.6in]{./Figures/Deployment_Process_2.jpg}
%   \caption{Automatic parallel deployment process}
%   \label{fig:deployment} 
% \end{figure}

\section{Statistical Background}
\label{sec:Statistical}

\section{Related Work}
\label{sec:relatedWork}
MAIN AREAS I WANT TO WRITE ABOUT:(IN NO ORDER)
1. AREA OF SELENIUM TESTS - LEOTTA ET AL PAPERS
2. AREA OF CRAWLERS - CRAWLJAX, WEBMOLE ETC
3. AREA OF CROSS BROWSER COMPATIBILITY TESTING
3. IN AREA OF TEST PREDICTION/DEFECT PREDICTION???
4. find 5 more papers to add
5. Add more references to bibliography and less footnotes

Since most of the web applications offer their primary user experience through the GUI layer, testing of web applications at GUI level is a vital part of software quality assurance procedures. To spare the effort and costs that comes with manual quality assurance, automating GUI testing is implemented. 

Marchetto et al.\cite{Marchetto2006} use an object oriented reverse engineering approach for testing web applications at unit, integration and system level. For system level testing using UML class diagrams, this approach builds a graphical representation of web application. By defining a coverage criteria and utilizing random walks, exploitable paths are identified to simulate navigation and traverse the AUT, such as page navigation and user inputs.  

In the area of automated crawler based testing,  Le Breton et al. \cite{le2013automated} propose a browser based crawler \textit{Webmole} to test Ajax based web applications. 
""" 
As mentioned in Section \ref{sec:AutomatedGUITesting}, automated GUI testing of modern web applications poses new challenges, particularly in the areas of test-input generation, test-output verification and state space exploration."""

"""
For newer versions, existing Selenium tests do not achieve the same functional coverage as they do for the version the tests are originally written for."""

Selenium tests are not robust if existing tests do not achieve the same functional coverage for newer application revisions as compared to the version the tests are written for. 

Test failures can be detected by using assertions in the code, analyzing test reports, verifying that the application is in the intended state by capturing the screen-shots, finite state models for the application state etc. While useful, these techniques suffer certain drawbacks such as investment of time as well as manual efforts required for the analysis of their outcome. 

Approaches involving screen-shot comparison might not be able to fully reveal the covered behavior and unexplored functionalities. Although finite state models can detect the covered functionalities, current implementations do not evaluate and compare these models for functional changes across different versions of an application. 

In the area of leveraging existing Selenium tests for generating behavioral models, the 'Testilizer' project by Mesbah et al \cite{testilizer} implements the combination of manual and automated test generation by leveraging hand-coded automation tests with automated crawling. This approach focuses on mining the human-written tests to explore additional application functionality which might be unexplored by the crawler. It implements strict automatic assertion generation and as a result, the exploration depth to cover available functionality is limited. 

Another approach by Mesbah and Prasad \cite{CBCMesbah} proposes behavioral and functional differential analysis in the area of cross-browser compatibility; however it inherits the drawbacks suffered by 'Testilizer' such as limited recursion depth and additional effort required to identify active GUI elements. Another approach to cross-browser testing involves ‘WebDiff’ by Choudhary et al \cite{WebDiff} which implements DOM-tree matching and pair wise screen-shot comparison to detect cross browser issues. Our approach leverages the principles behind cross-browser analysis and applies the techniques such as functional and GUI-level differential analysis to differentiate the behavioral coverage achieved by Selenium tests across different versions of the AUT.

As a comparative study of maintainability of Selenium WebDriver test-suites, Leotta et al \cite{leotta2013comparing} propose an approach to analyze the effectiveness and failure of Selenium tests on the basis of Element-locators. Their approach limits the analysis to a comparative study of element locators and does not consider other factors mentioned in Section \ref{sec:RobustnessFactors} responsible for the instability of Selenium tests. 

Considering the current state-of-the-art technologies to the best of my knowledge, there are no similar approaches to implement the robustness analysis of Selenium tests. Moreover, none of the aforementioned approaches evaluates the robustness of Selenium test-suites over the version history of the AUT. In contrast, our approach incorporates the existing techniques such as behavioral state models and GUI level comparisons to evaluate the robustness of Selenium tests and investigates the test failures across different regression cycles.